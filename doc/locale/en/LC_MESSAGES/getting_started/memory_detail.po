# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, dahu feng
# This file is distributed under the same license as the npu-sim package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: npu-sim\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-03 14:35+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: en <LL@li.org>\n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.17.0\n"

#: ../../source/getting_started/memory_detail.rst:4
msgid "内存访问与标签管理范式"
msgstr "Memory Access and Label Management Paradigm"

#: ../../source/getting_started/memory_detail.rst:6
msgid ""
"在 **NPU-SIM** 的实现中，所有数据块在SRAM读写的过程中都拥有一个唯一的标签，该标签在 "
":doc:`workload_config_detail` 中定义，用于标识数据块，并作为内存访问的索引。"
msgstr ""
"In the implementation of **NPU-SIM**, each data block has a unique tag "
"during SRAM read and write operations. This tag is defined in "
":doc:`workload_config_detail` and is used to identify the data block, "
"serving as an index for memory access."

#: ../../source/getting_started/memory_detail.rst:8
msgid "内存标签在工作负载配置文件中的命名规范见下，作为 :doc:`workload_config_detail` 的补充说明。"
msgstr ""
"The naming convention for memory tags in workload configuration files is "
"detailed below, serving as supplementary information to "
":doc:`workload_config_detail`."

#: ../../source/getting_started/memory_detail.rst:11
msgid "1. 标签保留规则"
msgstr "1. Tag Retention Rules"

#: ../../source/getting_started/memory_detail.rst:13
msgid ""
"在一个计算原语执行完毕后，默认会从内存中删除 **输入标签** 所对应的数据块。如果希望在后续的计算中使用该数据块，应在标签名前加上下划线 ``_`` "
"。"
msgstr ""
"After a compute primitive is executed, the data block corresponding to the "
"**input tag** is deleted from memory by default. If you wish to use this "
"data block in subsequent computations, you should prefix the tag name with "
"an underscore ``_``."

#: ../../source/getting_started/memory_detail.rst:15
msgid "示例"
msgstr "Example"

#: ../../source/getting_started/memory_detail.rst:18
msgid ""
"假设标签 ``x_out`` 作为原语1的输出，并在原语2中作为输入被使用。通常情况下，当原语2执行完毕之后，会从内存中删除 ``x_out`` "
"所对应的数据块（无论其在SRAM还是DRAM中）。然而当原语2在使用标签时，加上了下划线 ``_`` ，则表示该数据块在原语2执行完毕后，不会被删除。"
msgstr ""
"Assume the tag `x_out` is the output of primitive 1 and is used as input in "
"primitive 2. Typically, after primitive 2 finishes execution, the data block"
" corresponding to `x_out` (whether in SRAM or DRAM) is deleted from memory. "
"However, if an underscore `_` is appended to the tag when primitive 2 uses "
"it, it indicates that the data block will not be deleted after primitive 2 "
"finishes execution."

#: ../../source/getting_started/memory_detail.rst:49
msgid "2. 多输入与多输出"
msgstr "2. Multiple Input and Multiple Output"

#: ../../source/getting_started/memory_detail.rst:51
msgid ""
"在一个计算原语需要多个输入的情况下（如残差连接算子），使用空格分隔多个标签。（见上文中的示例， ``prim_3`` 的输入标签由两个标签 "
"``y_out`` 和 ``x_out`` 组成）"
msgstr ""
"When a computational primitive requires multiple inputs (such as a residual "
"connection operator), separate multiple labels with spaces. (See the example"
" above, where the input labels for ``prim_3`` consist of two labels, "
"``y_out`` and ``x_out``)"

#: ../../source/getting_started/memory_detail.rst:53
msgid ""
"原则上，一个计算原语只允许有一个输出标签。如若希望将输出均匀分割为多块，可参考原语的 :doc:`advanced_primitive_detail` "
"或使用 ``cast`` 的 ``weight`` 字段指定。"
msgstr ""
"In principle, a computational primitive is only allowed to have one output "
"label. If you wish to evenly split the output into multiple blocks, refer to"
" the primitive's :doc:`advanced_primitive_detail` or use the ``cast`` "
"primitive's ``weight`` field to specify."

#: ../../source/getting_started/memory_detail.rst:56
msgid "3. 特殊标签"
msgstr "3. Special Labels"

#: ../../source/getting_started/memory_detail.rst:58
msgid ""
"``input_label`` 指代由其他工作核传入本工作核的数据块。当工作核A向工作核B发送数据时，会自动在B的内存中创建一个名为 "
"``input_label`` 的数据块，并覆盖先前的同名数据块。此标签代表的数据块实际大小将由计算原语的参数自行决定。"
msgstr ""
"The ``input_label`` refers to the data block passed into this work core from"
" other work cores. When work core A sends data to work core B, a data block "
"named ``input_label`` is automatically created in B's memory, overwriting "
"any previous data block with the same name. The actual size of the data "
"block represented by this label is determined by the parameters of the "
"compute primitive."

#: ../../source/getting_started/memory_detail.rst:60
msgid "``dram_label x`` 指代该数据块应主动从DRAM中读取，在读取加载至SRAM中后会被命名为 ``x`` 。"
msgstr ""
"dram_label x indicates that this data block should be actively read from "
"DRAM and will be named x after being loaded into SRAM."

#: ../../source/getting_started/memory_detail.rst:62
msgid "``unset_label`` 指代未被定义的标签名， **不应** 出现在任何配置文件及日志输出文件中。"
msgstr ""
"The `unset_label` refers to an undefined label name and **should not** "
"appear in any configuration files or log output files."
